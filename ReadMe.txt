-following dependency includes JPA API, JPA Implementation, JDBC, and the other necessary libraries. Default JPA implementation is Hibernate
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
-Here I have used mssql as my database
-H2 database can be used instead since it's a very lightweight database
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
-Spring Boot checks for database configuration in application.properties and will create DataSource when spring-data-jpa is in the class-path
-spring.jpa.generate-ddl=true #independent to ORM vendor
-spring.jpa.hibernate.ddl-auto=create Hibernate specific feature. If create drop and recreate table
-@Entity annotation -class is an entity class.
-No @Table annotation ==> table name is "Customer"
-The @Id annotation mark the id field as unique id field. identity generation strategy.
-The firstName and lastName are not annotated ==> same column name as in the properties. @Column annotation to customize column names
-Spring JPA integration with the underlying JPA layer with JPA repositories to create repository implementations automatically, at run-time, from a repository interface
-@Repository annotation: to bootstrap the JPA features during component scanning.The JpaRepository provide several OOTB methods
save(S entity)
findById(ID id)
findOne()
findAll()
-createDatabaseIfNotExist=true : create table if not exist
-Doing these things needs permission for user:
SQL server instance -> Security -> Logins -> DB username -> right click -> properties -> Server roles, User Mapping on database and the membership
should be set here
-Entity classes can be equipped with auditing metadata that can be defined either using annotations or by implementing an interface.
-Spring JPA provides @CreatedBy, @LastModifiedBy to capture the user @CreatedDate and @LastModifiedDate to capture the time this happened.
-add @EntityListeners(AuditingEntityListener.class) to JPA entity class.
-Enable the JPA auditing in the main class using the @EnableJpaAuditing annotation
-In the development phase, seeing SQL statements generated by Hibernate can help. enable it by adding
#Statitcs and SQL logs
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.generate_statistics=true

#Enable this section based on your preferences
#logging.level.org.hibernate.type=trace
#logging.level.org.hibernate.stat=debug

logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
-set the database table name in Upper case ==>
spring.jpa.hibernate.naming.physical-strateg property and set the entity name accordingly (see Customer2)
-If that property is not there, Customer will create table named customer. If property is there, then create table Customer
-@Table(name = "JJOrder")
public class Order
need that annotation in my case. Order is reserved word in mssql
otherwise error:
2022-07-30 11:29:49 - GenerationTarget encountered exception accepting command : Error executing DDL "
    create table Order (
       id bigint identity not null,
        customer_id bigint,
        product_id bigint,
        primary key (id)
    )" via JDBC Statement